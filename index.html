<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sähkövahti</title>
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        :root { --bg: #121212; --card: #1e1e1e; --green: #2ecc71; --red: #e74c3c; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: white; padding: 20px; margin: 0; }
        .container { max-width: 600px; margin: auto; }
        .stats { display: flex; justify-content: space-between; margin: 20px 0; background: var(--card); padding: 20px; border-radius: 16px; }
        .stat-box { text-align: center; }
        .label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        .value { font-size: 1.2rem; font-weight: bold; display: block; }
        #chart-wrapper { background: var(--card); padding: 15px; border-radius: 16px; height: 50vh; position: relative; }
        #debug { font-size: 0.7rem; color: #444; text-align: center; margin-top: 10px; }
    </style>
</head>

<script>
    let chart;

    async function loadData() {
        const debug = document.getElementById('debug');
        const targetUrl = "https://sahkotin.fi/prices?quarter&fix&vat";
        
        // Try multiple proxies in case one is down/blocking
        const proxies = [
            `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
            `https://api.allorigins.win/get?url=${encodeURIComponent(targetUrl)}`
        ];

        for (let proxy of proxies) {
            try {
                debug.innerText = "Yritetään hakea tietoja...";
                const res = await fetch(proxy);
                if (!res.ok) throw new Error("Proxy error");
                
                let data;
                const text = await res.text();
                
                // AllOrigins returns a wrapper, corsproxy returns raw JSON
                try {
                    const json = JSON.parse(text);
                    data = json.contents ? JSON.parse(json.contents).prices : json.prices;
                } catch(e) {
                    throw new Error("JSON parse error");
                }

                if (data) {
                    processData(data);
                    debug.innerText = "Päivitetty: " + new Date().toLocaleTimeString();
                    return; // Success!
                }
            } catch (e) {
                console.warn("Proxy failed, trying next...", e);
            }
        }
        debug.innerText = "Virhe: Kaikki välityspalvelimet epäonnistuivat.";
    }

    function processData(data) {
        const now = new Date();
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        
        const pastData = data.filter(p => new Date(p.date) >= startOfMonth && new Date(p.date) <= now);
        const monthAvg = pastData.reduce((s, p) => s + p.value, 0) / (pastData.length || 1);

        const endLimit = new Date();
        endLimit.setDate(endLimit.getDate() + 1);
        endLimit.setHours(23, 59, 0);
        
        const futurePoints = data.filter(p => {
            const d = new Date(p.date);
            return d >= now && d <= endLimit;
        });

        const currentPrice = data.find(p => new Date(p.date) <= now && new Date(p.date) > new Date(now - 900000))?.value || 0;

        document.getElementById('now').innerText = currentPrice.toFixed(2) + "c";
        document.getElementById('avg').innerText = monthAvg.toFixed(2) + "c";
        const impact = currentPrice - monthAvg;
        const impEl = document.getElementById('impact');
        impEl.innerText = (impact > 0 ? "+" : "") + impact.toFixed(2);
        impEl.style.color = impact <= 0 ? "var(--green)" : "var(--red)";

        render(futurePoints, monthAvg);
    }

    function render(points, avg) {
        const ctx = document.getElementById('mainChart').getContext('2d');
        
        // Register the plugin specifically
        if (typeof ChartAnnotation !== 'undefined') {
            Chart.register(ChartAnnotation);
        }

        if (chart) chart.destroy();
        
        chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: points.map(p => {
                    const d = new Date(p.date);
                    return d.getMinutes() === 0 ? d.getHours() + ":00" : "";
                }),
                datasets: [{
                    data: points.map(p => p.value),
                    backgroundColor: points.map(p => p.value < avg ? '#2ecc71' : '#e74c3c'),
                    borderRadius: 3
                }]
            },
            options: {
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    legend: false,
                    annotation: {
                        annotations: {
                            line1: {
                                type: 'line',
                                yMin: avg, yMax: avg,
                                borderColor: 'rgba(255,255,255,0.5)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    display: true,
                                    content: 'KA: ' + avg.toFixed(2),
                                    position: 'end',
                                    backgroundColor: 'black',
                                    color: 'white',
                                    font: { size: 10 }
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: { grid: { color: '#333' }, ticks: { color: '#888' } },
                    x: { grid: { display: false }, ticks: { color: '#666', autoSkip: false, font: { size: 9 } } }
                }
            }
        });
    }

    loadData();
    setInterval(loadData, 900000);
</script>
